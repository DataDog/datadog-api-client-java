/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2019-Present Datadog, Inc.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.datadog.api.v1.client.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.datadog.api.v1.client.model.AlertGraphWidgetDefinition;
import com.datadog.api.v1.client.model.AlertValueWidgetDefinition;
import com.datadog.api.v1.client.model.ChangeWidgetDefinition;
import com.datadog.api.v1.client.model.CheckStatusWidgetDefinition;
import com.datadog.api.v1.client.model.DistributionWidgetDefinition;
import com.datadog.api.v1.client.model.EventStreamWidgetDefinition;
import com.datadog.api.v1.client.model.EventTimelineWidgetDefinition;
import com.datadog.api.v1.client.model.FreeTextWidgetDefinition;
import com.datadog.api.v1.client.model.GroupWidgetDefinition;
import com.datadog.api.v1.client.model.HeatMapWidgetDefinition;
import com.datadog.api.v1.client.model.HostMapWidgetDefinition;
import com.datadog.api.v1.client.model.HostMapWidgetDefinitionStyle;
import com.datadog.api.v1.client.model.IFrameWidgetDefinition;
import com.datadog.api.v1.client.model.ImageWidgetDefinition;
import com.datadog.api.v1.client.model.LogStreamWidgetDefinition;
import com.datadog.api.v1.client.model.MonitorSummaryWidgetDefinition;
import com.datadog.api.v1.client.model.NoteWidgetDefinition;
import com.datadog.api.v1.client.model.QueryValueWidgetDefinition;
import com.datadog.api.v1.client.model.SLOWidgetDefinition;
import com.datadog.api.v1.client.model.ScatterPlotWidgetDefinition;
import com.datadog.api.v1.client.model.ServiceMapWidgetDefinition;
import com.datadog.api.v1.client.model.ServiceSummaryWidgetDefinition;
import com.datadog.api.v1.client.model.TableWidgetDefinition;
import com.datadog.api.v1.client.model.TimeseriesWidgetDefinition;
import com.datadog.api.v1.client.model.ToplistWidgetDefinition;
import com.datadog.api.v1.client.model.ToplistWidgetDefinitionType;
import com.datadog.api.v1.client.model.ToplistWidgetRequest;
import com.datadog.api.v1.client.model.Widget;
import com.datadog.api.v1.client.model.WidgetAxis;
import com.datadog.api.v1.client.model.WidgetColorPreference;
import com.datadog.api.v1.client.model.WidgetEvent;
import com.datadog.api.v1.client.model.WidgetEventSize;
import com.datadog.api.v1.client.model.WidgetGrouping;
import com.datadog.api.v1.client.model.WidgetImageSizing;
import com.datadog.api.v1.client.model.WidgetLayoutType;
import com.datadog.api.v1.client.model.WidgetLegendSize;
import com.datadog.api.v1.client.model.WidgetMargin;
import com.datadog.api.v1.client.model.WidgetMarker;
import com.datadog.api.v1.client.model.WidgetMessageDisplay;
import com.datadog.api.v1.client.model.WidgetMonitorSummarySort;
import com.datadog.api.v1.client.model.WidgetNodeType;
import com.datadog.api.v1.client.model.WidgetServiceSummaryDisplayFormat;
import com.datadog.api.v1.client.model.WidgetSizeFormat;
import com.datadog.api.v1.client.model.WidgetSummaryType;
import com.datadog.api.v1.client.model.WidgetTextAlign;
import com.datadog.api.v1.client.model.WidgetTickEdge;
import com.datadog.api.v1.client.model.WidgetTime;
import com.datadog.api.v1.client.model.WidgetTimeWindows;
import com.datadog.api.v1.client.model.WidgetViewMode;
import com.datadog.api.v1.client.model.WidgetVizType;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.datadog.api.v1.client.JSON;

import com.fasterxml.jackson.core.type.TypeReference;

import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.datadog.api.v1.client.JSON;


@JsonDeserialize(using = WidgetDefinition.WidgetDefinitionDeserializer.class)
@JsonSerialize(using = WidgetDefinition.WidgetDefinitionSerializer.class)
public class WidgetDefinition extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(WidgetDefinition.class.getName());

    public static class WidgetDefinitionSerializer extends StdSerializer<WidgetDefinition> {
        public WidgetDefinitionSerializer(Class<WidgetDefinition> t) {
            super(t);
        }

        public WidgetDefinitionSerializer() {
            this(null);
        }

        @Override
        public void serialize(WidgetDefinition value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class WidgetDefinitionDeserializer extends StdDeserializer<WidgetDefinition> {
        public WidgetDefinitionDeserializer() {
            this(WidgetDefinition.class);
        }

        public WidgetDefinitionDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public WidgetDefinition deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            int match = 0;
            // deserialize AlertGraphWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(AlertGraphWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'AlertGraphWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AlertGraphWidgetDefinition'", e);
            }

            // deserialize AlertValueWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(AlertValueWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'AlertValueWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AlertValueWidgetDefinition'", e);
            }

            // deserialize ChangeWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ChangeWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'ChangeWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ChangeWidgetDefinition'", e);
            }

            // deserialize CheckStatusWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(CheckStatusWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'CheckStatusWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CheckStatusWidgetDefinition'", e);
            }

            // deserialize DistributionWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(DistributionWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'DistributionWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'DistributionWidgetDefinition'", e);
            }

            // deserialize EventStreamWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(EventStreamWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'EventStreamWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'EventStreamWidgetDefinition'", e);
            }

            // deserialize EventTimelineWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(EventTimelineWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'EventTimelineWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'EventTimelineWidgetDefinition'", e);
            }

            // deserialize FreeTextWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(FreeTextWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'FreeTextWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'FreeTextWidgetDefinition'", e);
            }

            // deserialize GroupWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(GroupWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'GroupWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'GroupWidgetDefinition'", e);
            }

            // deserialize HeatMapWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(HeatMapWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'HeatMapWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'HeatMapWidgetDefinition'", e);
            }

            // deserialize HostMapWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(HostMapWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'HostMapWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'HostMapWidgetDefinition'", e);
            }

            // deserialize IFrameWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(IFrameWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'IFrameWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'IFrameWidgetDefinition'", e);
            }

            // deserialize ImageWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ImageWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'ImageWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ImageWidgetDefinition'", e);
            }

            // deserialize LogStreamWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogStreamWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogStreamWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogStreamWidgetDefinition'", e);
            }

            // deserialize MonitorSummaryWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(MonitorSummaryWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'MonitorSummaryWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'MonitorSummaryWidgetDefinition'", e);
            }

            // deserialize NoteWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(NoteWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'NoteWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'NoteWidgetDefinition'", e);
            }

            // deserialize QueryValueWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(QueryValueWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'QueryValueWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'QueryValueWidgetDefinition'", e);
            }

            // deserialize SLOWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SLOWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'SLOWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'SLOWidgetDefinition'", e);
            }

            // deserialize ScatterPlotWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ScatterPlotWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'ScatterPlotWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ScatterPlotWidgetDefinition'", e);
            }

            // deserialize ServiceMapWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ServiceMapWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'ServiceMapWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ServiceMapWidgetDefinition'", e);
            }

            // deserialize ServiceSummaryWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ServiceSummaryWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'ServiceSummaryWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ServiceSummaryWidgetDefinition'", e);
            }

            // deserialize TableWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(TableWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'TableWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'TableWidgetDefinition'", e);
            }

            // deserialize TimeseriesWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(TimeseriesWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'TimeseriesWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'TimeseriesWidgetDefinition'", e);
            }

            // deserialize ToplistWidgetDefinition
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ToplistWidgetDefinition.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'ToplistWidgetDefinition'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ToplistWidgetDefinition'", e);
            }

            if (match == 1) {
                WidgetDefinition ret = new WidgetDefinition();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for WidgetDefinition: %d classes match result, expected 1", match));
        }


        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public WidgetDefinition getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "WidgetDefinition cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public final static Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public WidgetDefinition() {
        super("oneOf", Boolean.FALSE);
    }

    public WidgetDefinition(AlertGraphWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(AlertValueWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(ChangeWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(CheckStatusWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(DistributionWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(EventStreamWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(EventTimelineWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(FreeTextWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(GroupWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(HeatMapWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(HostMapWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(IFrameWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(ImageWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(LogStreamWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(MonitorSummaryWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(NoteWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(QueryValueWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(SLOWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(ScatterPlotWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(ServiceMapWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(ServiceSummaryWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(TableWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(TimeseriesWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WidgetDefinition(ToplistWidgetDefinition o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AlertGraphWidgetDefinition", new GenericType<AlertGraphWidgetDefinition>() {
        });
        schemas.put("AlertValueWidgetDefinition", new GenericType<AlertValueWidgetDefinition>() {
        });
        schemas.put("ChangeWidgetDefinition", new GenericType<ChangeWidgetDefinition>() {
        });
        schemas.put("CheckStatusWidgetDefinition", new GenericType<CheckStatusWidgetDefinition>() {
        });
        schemas.put("DistributionWidgetDefinition", new GenericType<DistributionWidgetDefinition>() {
        });
        schemas.put("EventStreamWidgetDefinition", new GenericType<EventStreamWidgetDefinition>() {
        });
        schemas.put("EventTimelineWidgetDefinition", new GenericType<EventTimelineWidgetDefinition>() {
        });
        schemas.put("FreeTextWidgetDefinition", new GenericType<FreeTextWidgetDefinition>() {
        });
        schemas.put("GroupWidgetDefinition", new GenericType<GroupWidgetDefinition>() {
        });
        schemas.put("HeatMapWidgetDefinition", new GenericType<HeatMapWidgetDefinition>() {
        });
        schemas.put("HostMapWidgetDefinition", new GenericType<HostMapWidgetDefinition>() {
        });
        schemas.put("IFrameWidgetDefinition", new GenericType<IFrameWidgetDefinition>() {
        });
        schemas.put("ImageWidgetDefinition", new GenericType<ImageWidgetDefinition>() {
        });
        schemas.put("LogStreamWidgetDefinition", new GenericType<LogStreamWidgetDefinition>() {
        });
        schemas.put("MonitorSummaryWidgetDefinition", new GenericType<MonitorSummaryWidgetDefinition>() {
        });
        schemas.put("NoteWidgetDefinition", new GenericType<NoteWidgetDefinition>() {
        });
        schemas.put("QueryValueWidgetDefinition", new GenericType<QueryValueWidgetDefinition>() {
        });
        schemas.put("SLOWidgetDefinition", new GenericType<SLOWidgetDefinition>() {
        });
        schemas.put("ScatterPlotWidgetDefinition", new GenericType<ScatterPlotWidgetDefinition>() {
        });
        schemas.put("ServiceMapWidgetDefinition", new GenericType<ServiceMapWidgetDefinition>() {
        });
        schemas.put("ServiceSummaryWidgetDefinition", new GenericType<ServiceSummaryWidgetDefinition>() {
        });
        schemas.put("TableWidgetDefinition", new GenericType<TableWidgetDefinition>() {
        });
        schemas.put("TimeseriesWidgetDefinition", new GenericType<TimeseriesWidgetDefinition>() {
        });
        schemas.put("ToplistWidgetDefinition", new GenericType<ToplistWidgetDefinition>() {
        });
        JSON.registerDescendants(WidgetDefinition.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return WidgetDefinition.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas.
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(AlertGraphWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AlertValueWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ChangeWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CheckStatusWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(DistributionWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(EventStreamWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(EventTimelineWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(FreeTextWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(GroupWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(HeatMapWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(HostMapWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(IFrameWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ImageWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogStreamWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(MonitorSummaryWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(NoteWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(QueryValueWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SLOWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ScatterPlotWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ServiceMapWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ServiceSummaryWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(TableWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(TimeseriesWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ToplistWidgetDefinition.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AlertGraphWidgetDefinition, AlertValueWidgetDefinition, ChangeWidgetDefinition, CheckStatusWidgetDefinition, DistributionWidgetDefinition, EventStreamWidgetDefinition, EventTimelineWidgetDefinition, FreeTextWidgetDefinition, GroupWidgetDefinition, HeatMapWidgetDefinition, HostMapWidgetDefinition, IFrameWidgetDefinition, ImageWidgetDefinition, LogStreamWidgetDefinition, MonitorSummaryWidgetDefinition, NoteWidgetDefinition, QueryValueWidgetDefinition, SLOWidgetDefinition, ScatterPlotWidgetDefinition, ServiceMapWidgetDefinition, ServiceSummaryWidgetDefinition, TableWidgetDefinition, TimeseriesWidgetDefinition, ToplistWidgetDefinition");
    }



}

