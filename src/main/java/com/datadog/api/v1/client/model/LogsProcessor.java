/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2019-Present Datadog, Inc.
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.datadog.api.v1.client.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.datadog.api.v1.client.model.LogsArithmeticProcessor;
import com.datadog.api.v1.client.model.LogsAttributeRemapper;
import com.datadog.api.v1.client.model.LogsCategoryProcessor;
import com.datadog.api.v1.client.model.LogsCategoryProcessorCategories;
import com.datadog.api.v1.client.model.LogsDateRemapper;
import com.datadog.api.v1.client.model.LogsFilter;
import com.datadog.api.v1.client.model.LogsGeoIPParser;
import com.datadog.api.v1.client.model.LogsGrokParser;
import com.datadog.api.v1.client.model.LogsGrokParserRules;
import com.datadog.api.v1.client.model.LogsLookupProcessor;
import com.datadog.api.v1.client.model.LogsMessageRemapper;
import com.datadog.api.v1.client.model.LogsPipelineProcessor;
import com.datadog.api.v1.client.model.LogsServiceRemapper;
import com.datadog.api.v1.client.model.LogsStatusRemapper;
import com.datadog.api.v1.client.model.LogsStringBuilderProcessor;
import com.datadog.api.v1.client.model.LogsTraceRemapper;
import com.datadog.api.v1.client.model.LogsTraceRemapperType;
import com.datadog.api.v1.client.model.LogsURLParser;
import com.datadog.api.v1.client.model.LogsUserAgentParser;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.datadog.api.v1.client.JSON;

import com.fasterxml.jackson.core.type.TypeReference;

import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.datadog.api.v1.client.JSON;


@JsonDeserialize(using = LogsProcessor.LogsProcessorDeserializer.class)
@JsonSerialize(using = LogsProcessor.LogsProcessorSerializer.class)
public class LogsProcessor extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(LogsProcessor.class.getName());

    public static class LogsProcessorSerializer extends StdSerializer<LogsProcessor> {
        public LogsProcessorSerializer(Class<LogsProcessor> t) {
            super(t);
        }

        public LogsProcessorSerializer() {
            this(null);
        }

        @Override
        public void serialize(LogsProcessor value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class LogsProcessorDeserializer extends StdDeserializer<LogsProcessor> {
        public LogsProcessorDeserializer() {
            this(LogsProcessor.class);
        }

        public LogsProcessorDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public LogsProcessor deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            int match = 0;
            // deserialize LogsArithmeticProcessor
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsArithmeticProcessor.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsArithmeticProcessor'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsArithmeticProcessor'", e);
            }

            // deserialize LogsAttributeRemapper
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsAttributeRemapper.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsAttributeRemapper'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsAttributeRemapper'", e);
            }

            // deserialize LogsCategoryProcessor
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsCategoryProcessor.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsCategoryProcessor'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsCategoryProcessor'", e);
            }

            // deserialize LogsDateRemapper
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsDateRemapper.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsDateRemapper'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsDateRemapper'", e);
            }

            // deserialize LogsGeoIPParser
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsGeoIPParser.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsGeoIPParser'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsGeoIPParser'", e);
            }

            // deserialize LogsGrokParser
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsGrokParser.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsGrokParser'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsGrokParser'", e);
            }

            // deserialize LogsLookupProcessor
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsLookupProcessor.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsLookupProcessor'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsLookupProcessor'", e);
            }

            // deserialize LogsMessageRemapper
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsMessageRemapper.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsMessageRemapper'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsMessageRemapper'", e);
            }

            // deserialize LogsPipelineProcessor
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsPipelineProcessor.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsPipelineProcessor'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsPipelineProcessor'", e);
            }

            // deserialize LogsServiceRemapper
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsServiceRemapper.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsServiceRemapper'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsServiceRemapper'", e);
            }

            // deserialize LogsStatusRemapper
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsStatusRemapper.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsStatusRemapper'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsStatusRemapper'", e);
            }

            // deserialize LogsStringBuilderProcessor
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsStringBuilderProcessor.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsStringBuilderProcessor'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsStringBuilderProcessor'", e);
            }

            // deserialize LogsTraceRemapper
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsTraceRemapper.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsTraceRemapper'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsTraceRemapper'", e);
            }

            // deserialize LogsURLParser
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsURLParser.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsURLParser'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsURLParser'", e);
            }

            // deserialize LogsUserAgentParser
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(LogsUserAgentParser.class);
                // TODO: there is no validation against JSON schema constraints
                // (min, max, enum, pattern...), this does not perform a strict JSON
                // validation, which means the 'match' count may be higher than it should be.
                match++;
                log.log(Level.FINER, "Input data matches schema 'LogsUserAgentParser'");
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'LogsUserAgentParser'", e);
            }

            if (match == 1) {
                LogsProcessor ret = new LogsProcessor();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for LogsProcessor: %d classes match result, expected 1", match));
        }


        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public LogsProcessor getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "LogsProcessor cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public final static Map<String, GenericType> schemas = new HashMap<String, GenericType>();

    public LogsProcessor() {
        super("oneOf", Boolean.FALSE);
    }

    public LogsProcessor(LogsArithmeticProcessor o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsAttributeRemapper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsCategoryProcessor o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsDateRemapper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsGeoIPParser o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsGrokParser o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsLookupProcessor o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsMessageRemapper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsPipelineProcessor o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsServiceRemapper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsStatusRemapper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsStringBuilderProcessor o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsTraceRemapper o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsURLParser o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public LogsProcessor(LogsUserAgentParser o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("LogsArithmeticProcessor", new GenericType<LogsArithmeticProcessor>() {
        });
        schemas.put("LogsAttributeRemapper", new GenericType<LogsAttributeRemapper>() {
        });
        schemas.put("LogsCategoryProcessor", new GenericType<LogsCategoryProcessor>() {
        });
        schemas.put("LogsDateRemapper", new GenericType<LogsDateRemapper>() {
        });
        schemas.put("LogsGeoIPParser", new GenericType<LogsGeoIPParser>() {
        });
        schemas.put("LogsGrokParser", new GenericType<LogsGrokParser>() {
        });
        schemas.put("LogsLookupProcessor", new GenericType<LogsLookupProcessor>() {
        });
        schemas.put("LogsMessageRemapper", new GenericType<LogsMessageRemapper>() {
        });
        schemas.put("LogsPipelineProcessor", new GenericType<LogsPipelineProcessor>() {
        });
        schemas.put("LogsServiceRemapper", new GenericType<LogsServiceRemapper>() {
        });
        schemas.put("LogsStatusRemapper", new GenericType<LogsStatusRemapper>() {
        });
        schemas.put("LogsStringBuilderProcessor", new GenericType<LogsStringBuilderProcessor>() {
        });
        schemas.put("LogsTraceRemapper", new GenericType<LogsTraceRemapper>() {
        });
        schemas.put("LogsURLParser", new GenericType<LogsURLParser>() {
        });
        schemas.put("LogsUserAgentParser", new GenericType<LogsUserAgentParser>() {
        });
        JSON.registerDescendants(LogsProcessor.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, GenericType> getSchemas() {
        return LogsProcessor.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas.
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(LogsArithmeticProcessor.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsAttributeRemapper.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsCategoryProcessor.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsDateRemapper.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsGeoIPParser.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsGrokParser.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsLookupProcessor.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsMessageRemapper.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsPipelineProcessor.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsServiceRemapper.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsStatusRemapper.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsStringBuilderProcessor.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsTraceRemapper.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsURLParser.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(LogsUserAgentParser.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be LogsArithmeticProcessor, LogsAttributeRemapper, LogsCategoryProcessor, LogsDateRemapper, LogsGeoIPParser, LogsGrokParser, LogsLookupProcessor, LogsMessageRemapper, LogsPipelineProcessor, LogsServiceRemapper, LogsStatusRemapper, LogsStringBuilderProcessor, LogsTraceRemapper, LogsURLParser, LogsUserAgentParser");
    }



}

